#ifndef CAMERA_H
#define CAMERA_H

// 我们应该把一些所有子类都会用到的头文件全都放在base class中include, 因为在子类include base class之时, base class的头文件必然自动会被子类所include.
#include "utility.h"

class camera {
    public:
        /*
            相机可以在3D空间中随意位置, 这里我们规定成像平面一定和相机的视野方向垂直, 也就是相机本身的object space的w轴方向与成像平面垂直. 
            渲染图像使用的是u-v坐标系, 每一个第i行第j列的像素点在u-v平面有其坐标位置.
            成像平面宽高比例与渲染图像宽高比例相同. 
            
            我们通过定义相机的视角和聚焦距离来定义成像平面的高度. 再通过渲染图像的屏幕比例定义成像平面的宽度.
            我们说先规定渲染图像的分辨率, 然后规定成像平面的大小, 从而把渲染图像的每个像素点的(u,v)坐标值都映射到成像平面对应的坐标位置上的(x,y)坐标值.
            
            default and parameter constructor => 通过解读摄像机构造函数的input parameters, 就能很好的理解我们可以自由对摄像机设置的参数.
            lookfrom        =>      表示摄像机在3D场景中的位置(世界坐标系), 定义了摄像机在3D场景中的position.   
            lookat          =>      也就是摄像机look at的点(世界坐标系), 伙同lookfrom生成的向量定义了摄像机在3D场景中的orientation.
                                    lookfrom和lookat这两个参数是最重要的参数之一. 这两个参数唯一确定了摄像机的position和orientation, 同时也确定了摄像机object space的w方向
                                    camera = {Position    : lookfrom,   Orientation : lookat - lookfrom}
                                    w = lookfrom - lookat.   右手坐标系
            vup             =>      view up vector, 通常vup = (0,1,0). 随机给定一个向量伙同摄像机的orientation来来构建camera的object space and (u,v,w) 右手坐标系.
            
            aov             =>      angle of view, 视角, 也就是摄像机的可视角度, 摄像机所能看到3D场景的视野范围. 这里单位是度数, 内部再转化为幅度radian为单位.
                                    根据标准视角公式, aov = arctan(half_h/*f), 其中half_h为成像平面的半高, f为焦距(焦点离透镜的距离). 给定一个透镜的参数焦距就唯一确定.
                                    由视角公式从而有tan(aov) = half_h / f  => half_h = tan(aov) * f, 也就说给定了aov和焦距, 就唯一确定了成像平面的高度.
                                    1). 视角越大, 从视点发出的射线的最大角度就越大, 可视光线就越分散, 这就意味着视野范围越宽, 与此同时依透视投影原理物体的显示比例就越小, 物体纹理显示越模糊.
                                    2). 视角越小, 从视点发出的射线的最大角度就越小, 可视光线就越聚集, 这就意味着视野范围越窄, 与此同时依透视投影原理物体的显示比例就越大, 物体纹理显示越清晰.
            aspect_ratio    =>      屏幕比例, 宽高比 = 宽 / 高. aov决定成像平面的高度, 再使用屏幕比例参数就唯一确定了成像平面的宽度.
                                    aov和aspect_ratio这两个参数唯一的确定了成像平面的大小.
                                    image_plane = {height = 2.0*tan(aov),   width = height*aspect_ratio}
            focus_dist      =>      光圈(视点)到聚焦平面的距离, 聚焦平面是3D场景空间中的一个2D平面, 这一个2D平面上的任意一个点发出的光线都能汇聚在成像平面上的一个独立点处,
                                    这意味着聚焦平面上所有点都能够在成像平面上最清晰显示. 聚焦平面的前后能够在成像平面上清晰显示的距离被称作景深.
                                    在CG中模拟软聚焦景深的方法, 虽然是类似透镜成像的方法, 但做了简化没有那么复杂, 而且一些概念和透镜成像并不相同.
                                    因此在理解CG成像中, 我们可以借鉴小孔相机和透镜相机成像的原理, 但绝不能简单套用, 不然本来很浅显明了的CG实现方法都会弄的晕头转向.
                                    原理: 透镜成像中, 当物体不在聚焦平面上时, 汇聚到成像平面上某一点的光线不再全部来自物体上的一点, 而是来自物体上的一小片区域, 这样就形成了模糊的效果.
                                          对于CG的景深模拟, 其核心思想也就是在这里, 如果一个像素点接受到多条光线, 并且这多条光线不是出自于同一个物体点, 那自然这个像素的颜色就会"模糊".
                                            a. 如果我们只有一个固定的视点, 那么即使视点往成像平面某个像素点发出多条光线, 那么这些光线都会是一个方向, 无法模拟出多条光线照射像素点的情景.
                                               因此我们可以以视点为中心在包含视点与w轴垂直的平面定义一个圆盘, 这个圆盘用来模拟透镜/光圈. 我们可以在这个光圈上随机取视点的位置, 
                                               每一个随机位置都往像素点发射一条可视射线, 如此就模拟了汇聚到像素点的光线来自于不同的物体空间点(除了焦平面).
                                            b. 如何确定焦平面? 既然我们有了光圈发出的随机光线会汇聚在成像平面的像素点上, 那自然成像平面就是焦平面了.
                                               移动成像平面相对于摄像机的位置, 就是在移动我们想要聚焦的平面. 成像平面前后仍然能在平面上清晰成像的距离就是景深了.
                                               光圈越大, 那么从随机视点到像素点方向的角度(水平夹角)就能越大, 景深就越窄; 光圈越小, 那么从随机视点到像素点方向的角度就越小, 景深越广.
                                            3. 因为成像平面就是聚焦平面, 所以没有严格的焦距概念. 直接使用focus_dist聚焦距离当做焦距, 并和aov伙同视角公式就可以计算出成像平面的高度.
                                               half_h = tan(aov) * focus_dist. 改变focus_dist就是在改变模拟光圈圆盘的焦距.
                                               知乎上说, 光学薄透镜和近轴光线的成像系统, 焦距和视角没有本质关系. 视角大小, 由"镜屏距"(透镜中心到成像屏幕的距离)和成像屏幕高度决定.
                                               所说的镜屏距那就是focus_dist, 因为我们已经把成像平面和聚焦平面重合放置.

            视角解释        =>      无穷远点的物体点因处于无穷远位置, 每个点发射到透镜的光线都被认为是平行的. 
                                    每个点在无穷远平面位置不同, 所以不同点以不同的角度(光线和光轴夹角, 可以是0度到接近90度)向着透镜的方向发射平行光线. 
                                    无穷远平面无穷的大, 所以显然不可能所有无穷平面的点都被收纳到相机的成像平面上. 
                                    因此就有这样一个无穷远光线和光轴的夹角, 决定了只有在这个夹角范围内的无穷远光线穿过透镜并被透镜折射之后可以收纳到成像平面上.
                                    这样的一个最大夹角就是视角. 决定视角大小的是什么呢? 
                                    很容易推测, 1. 成像平面高度肯定会影响能够收纳的穿过透镜的折射光线的范围吧.
                                                2. 透镜的折射能力肯定也会影响多广方向的光线仍然被折射到成像平面上吧.
                                                    换句话说, 透镜的焦距由透镜的折射能力直接决定. 所以透镜的焦距大小影响着光线被透镜折射的强度.
                                                    焦距越大, 透镜的折射能力也就越弱; 焦距越小透镜的折射能力也就越强.
                                    因此做个总结, 视角的大小显然是应该被成像平面的高度和透镜的折射能力(焦距)所共同决定的.
                                    还有个问题, 为什么要用所能照射到成像的无穷远光线和光轴的最大夹角来定义视角呢, 为什么不用其他3D空间平面上的点发出的光线能够照射到成像平面的和光轴最大夹角?
                                    答: 因为其他成像平面上的点所发出的光线, 以这个点位置和光线方向(透镜方向)反推直线的话, 都能追溯到无穷远平面上某点发出的平行光线中的某束.
                                        因此通过无穷远平面上的点的光线确定的视角能够保证, 在这一角度范围内的所有空间点发出的光线, 至少有一束能够被透镜折射然后收纳到成像平面上.
                                        而在这一角度范围外的空间点, 所有发射出的射线经透镜折射都无法收纳到成像平面上.
        */
        camera(const point3 lookfrom = point3(0.0, 0.0, 0.0),       // 默认摄像机位置为世界坐标系原点.
               const point3 lookat = point3(0.0, 0.0, -1.0),        // 默认摄像机方向点位于w=-1平面中心处.
               const vec3 vup = vec3(0.0, 1.0, 0.0),                // 默认使用view up vector=(0,1,0)来构建u-v-w摄像机object space
               const double aov = 90.0,                             // 默认摄像机视角为90.
               const double aspect_ratio = 16.0/90.0,               // 默认成像平面宽高比例16:9.
               const double aperture = 0.0,                         // 默认光圈直径为0.0, 即模拟小孔成像摄像机; 非0光圈则模拟具有景深的透镜摄像机.
               const double focus_dist = 1.0) {                     // 默认聚焦距离为1.0, 也就是光圈(视点)离聚焦平面的距离.
            /* 

                我们现在实现的摄像机是以依据小孔成像或透镜成像为原理实现的. 
                小孔成像中, 所有照射到成像平面的光都必须首先汇聚到一个极小的点, 这个理想点让空间物体的每个点只能有且从这个点通过一束光照射到成像平面.
                而我们现在的照相机内部有一个视点, 视点前放置成像平面(就是把小孔成像的成像平面从左侧移到小孔的右侧), 所有的空间物体点都有会一束光汇聚到这一个视点, 并且在汇聚过程穿透成像平面.
                依据小孔成像原理实现的摄像机没有焦距的概念, 摄像机的视角由成像平面距离摄像机的距离和成像平面本身的高度决定.

                                         /|
                                      /   |
                                   /      |  
                                /         | h/2, 成像平面半高       
                             /            |
                            *-θ------------------------------> w轴          => 视角公式 tan(θ/2) = (h/2) / f      =>     θ = 2.0 * arctan(h/(2f)).
                             \        f 成像平面距离摄像机的距离.
                                \
                                   \
                                      \
                                        \
                在不移动成像平面的情况下, 视角越小, 视野宽度越窄, 但视野深度越深, 能看到的场景范围较小, 但是更能清晰看到远处的物体.
                                        视角越大, 视野宽度越宽, 但视野深度越浅, 能看到更大的场景范围, 当然物体比例变小, 清晰度也降低.
                
                定义在成像平面左侧任意位置的摄像机. 此时定义两个点就能确定摄像机的位置position和摄像机的方向orientation.
                    1. 一个是lookfrom点, 表示摄像机的位置, 也就是摄像机从这个点看成像平面.
                    2. 一个是lookat点. 也就是摄像机look at的点, lookfrom和lookat就可以唯一决定摄像机的方向向量.

                有了摄像机的position和orientation, 我们来建立摄像机的自身的object space, 即定义三个互相垂直的单位基向量(u,v,w), 使用右手坐标系规则, 逆时针为正向. 
                    1. 依据右手坐标系规则, w方向定义为lookat反方向, 也就是lookfrom到lookat的反方向. 所以-w方向表示的是camera的朝向方向. 记得单位化w
                    2. w方向建立好了, 我们就构建垂直于w的u-v平面. 要想建立u-v平面, 我们必须要再给定一个世界坐标系下的任意向量, 然后通过外积来求u和v.
                        2.1 最常用的做法是给定一个view upright vector vup = (0,1,0).
                        2.2 然后利用叉乘求出向量u = cross(vup, w)  右手坐标系, 叉乘要注意向量前后顺序.  记得单位化u
                        2.3 然后再利用叉乘求出向量v = corss(w, v)  右手坐标系, 叉乘要注意向量前后顺序.  记得单位化v
            */
            double theta  = degrees_to_radian(aov);                         // 把视角转化成幅度为单位.
            double half_h = tan(theta / 2.0) * focus_dist;                  // 通过视角和聚焦距离唯一确定成像平面高度.

            double viewpoint_height = 2.0 * half_h;                         // 视点可视高度, 决定成像平面的高度. 也即是y轴取值[-1, 1].
            double viewpoint_width  = aspect_ratio * viewpoint_height;      // 视点可视宽度, 决定成像平面的宽度, 也即是x轴的取值[-viewpoint_width/2.0, viewpoint_width/2.0]

            // 构建camera object space, i.e. (u,v,w) right-handed coordinate system.
            w = unit_vector(lookfrom - lookat);
            u = unit_vector(cross(vup, w));
            v = unit_vector(cross(w, u));

            origin            = lookfrom;                                               // 定义摄像机所处的空间位置.
            // 计算出成像平面左下角顶点, 以及表示成像平面宽度的u轴正向向量和v轴正向向量. 所以给定u轴和v轴关于程序平面高度和宽度的fraction value, 就能确定像素点所处的外置.
            horizontal        = viewpoint_width * u;                                    // 定义成像平面u轴方向的正向向量, 长度为viewpoint_width.
            vertical          = viewpoint_height * v;                                   // 定义成像平面v轴方向的正向向量, 长度为viewpoint_height
            lower_left_vertex = origin - horizontal/2.0 - vertical/2.0 - focus_dist*w;  // 计算成像平面左下角顶点的世界坐标系坐标. 成像平面的中心点就在w表示的坐标位置.
                                                                                        // 在object space下w = (0,0,-focus_dist).
            lens_radius = aperture / 2.0;
        }
    public:
        // 定义get_ray生成射线函数, input参数s一个[0,1]之间的数, 用于确定像素点在成像平面的u轴位置. input参数t一个[0,1]之间的数, 用于确定像素点在成像平面的v轴位置
        ray get_ray(const double s, const double t) const {
            // 如果想要直接在u-v平面以原视点为圆心的圆盘取随机offset偏移量比较困难, 所以我们可以先在标准的世界坐标系下的同半径圆盘上取随机点, 然后再把轴分量值变换成u-v平面的轴分量值.
            //  1. 首先在世界坐标系下, 半径为lens_radius圆心为(0,0,0)的x-y平面上的圆盘内随机取一个点, 这一个随机点向量的x轴和y轴分量非0, 长度小于1.
            //  2. u-v平面有表示坐标系的标准单位基向量u和v, 因此直接把x的分量乘以基向量u就是在u轴上的随机偏移量, 把y的分量乘以基向量v就是在v轴上的随机偏移量. 何在一起就是offset向量.
            vec3 rd = lens_radius * random_in_unit_disk();      // 如果lens_radius=0.0, 那么就没有偏移量, 即没有散焦模糊效果.
            vec3 offset = rd.x()*u + rd.y()*v;
            vec3 random_origin = origin + offset;                  // 生成随机视点位置. new_origin和origin处于同一u-v平面.

            // 以视点射向成像平面最左下角顶点的射线为base, 通过add在horizontal所代表的的x轴基向量和vertical所代表的y轴基向量的增量offset, 来确定正确的穿过成像平面"像素点"的射线.
            // base_dir     = lower_left_corner - origin        => 表示的是 以视点射向成像平面最左下角顶点的射线
            // u_dir_offset = s*horizontal;                     => offset to .
            // v_dir_offset = t*vertical;                       => 表示的是像素点在成像平面的沿v轴的世界坐标值.
            return ray(random_origin, (lower_left_vertex - random_origin) + s*horizontal + t*vertical);
        }
    private:
        // camera有大体四个数据成员.     
        point3 origin;                  // origin表示camera在空间坐标系中所处的位置.                   
        
        point3 lower_left_vertex;       // 定义成像平面左下角顶点空间坐标.
        vec3 horizontal;                // 定义成像平面的水平正向向量.  也就是x轴方向基向量, 长度为viewpoint_width. 即表示x轴正向方向也表示成像平面的宽度.              
        vec3 vertical;                  // 定义成像平面的垂直正向向量.  也就是y轴方向基向量, 长度为viewpoint_height. 即表示y轴的正向方向也表示成像平面的高度.

        vec3 u, v, w;                   // 定义camera的object space. u-v-w相互垂直的标准单位基向量. 右手坐标系, w轴负方向表示摄像机的正朝向.

        double lens_radius;             // 定义摄像机光圈半径.
};

#endif